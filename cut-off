car_system.h:
generate(); switch lane
std::size_t gap_left_lane = 0, gap_right_lane = 0;

if(lane != 0 && config.get_street_lanes() > 1)
{
	timeout = 0;
	while(timeout++ < config.get_max_speed()
		  && !is_car_at(++pos_temp % config.get_street_length(), lane - 1)
		  && !is_barrier_at(pos_temp % config.get_street_length(), lane - 1))
		;

	if(timeout > 1)
		gap_left_lane = timeout - 2;
}
if((lane + 1) < config.get_street_lanes())
{
	timeout = 0;
	while(timeout++ < config.get_max_speed()
		  && !is_car_at(++pos_temp % config.get_street_length(), lane + 1)
		  && !is_barrier_at(pos_temp % config.get_street_length(), lane + 1))
		;

	if(timeout > 1)
		gap_right_lane = timeout - 2;
}

if(gap_left_lane > gap || gap_right_lane > gap)
{
	if(gap_left_lane < gap_right_lane)
	{
		speed = gap_right_lane;
		++new_lane;
	}
	else
	{
		speed = gap_left_lane;
		--new_lane;
	}
}
else
	speed = gap;
}

// random slow down car is driving (speed != 0)
if(dist_slow_down(mt) < config.get_slow_down_chance() && speed)
--speed;

std::size_t speed_copy = speed;
for(std::size_t a = 1; a < speed_copy && speed; ++a)
if(is_slow_down_at(pos + a, lane))
	--speed;

// set car in next system
system[current_system ^ 0x01][new_lane][(pos + speed) % config.get_street_length()].speed = speed;
system[current_system ^ 0x01][new_lane][(pos + speed) % config.get_street_length()].id = system[current_system][lane][pos].id;
}
else if(is_barrier_at(pos, lane))
system[current_system ^ 0x01][lane][pos].speed = -2;
}
}

for(std::size_t lane = 0; lane < config.get_street_lanes(); ++lane)
{
for(std::size_t pos = 0; pos < config.get_street_length(); ++pos)
{
if(is_car_at(pos, lane))
{
std::size_t speed = system[current_system][lane][pos].speed;
std::size_t new_lane = lane;

// determine gap to next car
std::size_t pos_temp = pos, timeout = 0;
while(timeout++ < config.get_max_speed()
  && (system[current_system ^ 0x01][lane][++pos_temp % config.get_street_length()].speed == -1)
  && (system[current_system ^ 0x01][lane][pos_temp % config.get_street_length()].speed != -3))
;

std::size_t gap = 0;
if(timeout)
 gap = timeout - 1;

if(speed < config.get_max_speed())
++speed;
if(gap < speed)
{
std::size_t gap_left_lane = 0, gap_right_lane = 0;

if(lane != 0 && config.get_street_lanes() > 1)
{
	timeout = 0;
	while(timeout++ < config.get_max_speed()
		  && !is_car_at(++pos_temp % config.get_street_length(), lane - 1)
		  && !is_barrier_at(pos_temp % config.get_street_length(), lane - 1))
		;

	if(timeout > 1)
		gap_left_lane = timeout - 2;
}
if((lane + 1) < config.get_street_lanes())
{
	timeout = 0;
	while(timeout++ < config.get_max_speed()
		  && !is_car_at(++pos_temp % config.get_street_length(), lane + 1)
		  && !is_barrier_at(pos_temp % config.get_street_length(), lane + 1))
		;

	if(timeout > 1)
		gap_right_lane = timeout - 2;
}

if(gap_left_lane > gap || gap_right_lane > gap)
{
	if(gap_left_lane < gap_right_lane)
	{
		speed = gap_right_lane;
		++new_lane;
	}
	else
	{
		speed = gap_left_lane;
		--new_lane;
	}
}
else
